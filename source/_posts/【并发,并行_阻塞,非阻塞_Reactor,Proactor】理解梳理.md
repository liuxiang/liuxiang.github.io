title: 【并发,并行_阻塞,非阻塞_Reactor,Proactor】理解梳理
date: 2018-5-9 00:00:00
categories: 并发
tags: [并发]

---

[TOC]

---
# 并发 & 并行
## 参照物:多个线程间相互参考
```
- 先从待办事项出发,考虑其内容的[`连续执行`,`交替执行`,`同时执行`]的场景
- 多个工作内容完全连续执行,最终完成多个工作 = 串行(并发的一种) `最耗时`
- 多个工作内容交替执行,最终完成多个工作 = 并发 `并未省时`
- 多个工作内容同时执行,最终完成多个工作 = 并行 `相对省时`

工作内容的同时执行
- 一则,看`业务`(如一些准备类事项外,大部分可同时执行)
- 二则,看`多核利用`(单核下的多线程任然是并发,多核下的并行线程才是并行)
    - 注意:多核环境并不一定同时利用,其中单核的并发调度会同时存在.所以,并发或并行尚`不可人为控制`.
- 三则,看`环境`(分布式环境下-多机器,天然为多核.天然并行)
    - 注意:并行量取决于同时工作的机器`并行计算`*单机核数`并行计算(不完成控制)`
        - 当工作项(或线程量)利用完所有机器,下一步交给单机多核还能扩展一定量`并行计算(不完全控制)`.
        - 再利用完多核,下一步则有各单内核给多线程`切片分配资源`,`并发计算`
```
见: 多线程并发,并行,QPS.md

---
# 同步 & 异步
## 参照物: 当前线程中各工作项间相互参考
- 当前线程中的顺序工作项[A,B]
    - A执行完,才能执行B时,表现为`同步`
    - A标记执行,但不需要等待其具体的完成,就能执行B时,表现为`异步`
        - 实现方式:A工作项,新建线程去完成具体工作.

---
# 阻塞 & 非阻塞 (网络环境体现为BIO/NIO)
## 参照物: 当前线程中执行某个具体的工作项(且具体工作依赖线程外资源)   
- 该工作项依赖的外部资源(如:DB,IO 也可以是CPU,memory)执行过程中
    - 当前线程如果`保持等待`其结果.表现为`阻塞`
    - 当前线程如果不等待其结果,将`待完成`的工作内容备份起来,立即去做`不依赖待完成工作的其它事情`. 表现为`非阻塞`
        - 实现方式(程序设计): `待完成`工作内容因为已备份,可以通过`周期检查`或`callback`等方式获得`待完成`工作的完成结果.
- `阻塞 & 非阻塞`也是一种程序执行的表现形式,通过程序的设计实现来表现. 
    - 当获取一个具体的外部资源依赖时,如能将过程提取出来,跳过等待即可实现`非阻塞`.默认情况下多见是`阻塞`的.

## 另一个视角:系统线程状态. 
- 系统
```
➜ ~ netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' #对各 种状态的连接数分组统计结果
FIN_WAIT_1 2
SYN_SENT 8
CLOSE_WAIT 12
TIME_WAIT 189
ESTABLISHED 55
```
- jvm
```
[admin@10-57-19-107 ~]$ process=`pidof java`;jstack $process > jstack.log;
[admin@10-57-19-107 ~]$ cat jstack.log | grep 'java.lang.Thread.State' | awk '{print $2$3$4$5}' | sort | uniq -c
      1 BLOCKED(onobjectmonitor)
     28 RUNNABLE
    171 TIMED_WAITING(onobjectmonitor)
     30 TIMED_WAITING(parking)
      3 TIMED_WAITING(sleeping)
      2 WAITING(onobjectmonitor)
    317 WAITING(parking)
```

---
# 同步阻塞IO & 同步非阻塞IO & 异步阻塞IO & 异步非阻塞IO
## 参照物: 是否利用`多线程`在访问`外部资源(io,db..)`时,又是否`保持等待`
- 同步阻塞IO : 主线程等待外部资源(io)的完成信号,再继续
- 同步非阻塞IO : 主线程不等待外部资源(io)的完成信号,而是记下来需等待的io工作,同时去其它事情.过程中设置询问待完成的结果.
- 异步阻塞IO : 建旁路线程去获取外部资源(io),过程中保持等待.
- 异步非阻塞IO : 新建旁路线程去获取外部资源(io),过程中备份等待事项,同时去做别的,过程中再及时检查待完成工作的情况.

`同步异步阻塞非阻塞Reactor模式和Proactor模式 （目前JAVA的NIO就属于同步非阻塞IO） - 王健男 - 博客园`
https://www.cnblogs.com/-wangjiannan/p/3723092.html

## 多路复用IO（multiplexing IO）& 信号驱动式IO（signal-driven IO）
- 多路复用IO : 资源通道的重用,可节省通道资源
- 信号驱动式IO : 程序设计模式,将重量的完成结果或过程,以信号的方式表现,与线程交流.分布获得最终外部资源.

---
# Reactor & Proactor  [均是非阻塞的封装表现]
## Reactor是`非阻塞的同步`方式, 而Proactor是`非阻塞的异步`方式
- Reactor：拿号，某个柜台空闲了就通知我去取款，我还是必须坐到柜台前取款，取款过程还是同步的。`[同步回收结果]`
- Proactor：拿号，告诉大堂经理我要取款，款到了，大唐经理送到我手中，取款过程是异步的。 `[异步回收结果]`
见: https://blog.csdn.net/llj1985/article/details/51558584

- 其它示例
    - reactor：能收了你跟俺说一声。`[一次性回收]`
    - proactor: 你给我收十个字节，收好了跟俺说一声。`[过程分段回收/流式通道(有一点给一点)]`
见: Reactor Proactor 事件模式[reactor/proactor].md

---
**参考**
`深入理解并发/并行，阻塞/非阻塞，同步/异步 - 简书`
https://www.jianshu.com/p/2116fff869b6

`对阻塞、非阻塞、异步、同步的理解 - 简书`
https://www.jianshu.com/p/32b1eed3c1f7

`同步异步，阻塞非阻塞，并行并发 - 简书`
https://www.jianshu.com/p/996798d897fb

`怎样理解阻塞非阻塞与同步异步的区别？ - 简书`
https://www.jianshu.com/p/02f76566fd90

`Spring webflux--响应式、非阻塞、事件驱型web框架 - CSDN博客`
https://blog.csdn.net/qiangcuo6087/article/details/79024646