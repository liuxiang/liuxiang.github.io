title: 抽奖场景——并发思考
date: 2016-3-4 00:00:03
categories:  并发控制

tags: [ 并发控制,程序锁使用 ]


---
# 锁类型 & 适用场景 
- 乐观锁
定义：很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制
适合：同时刻，低频改写 （多读少写）
优点：吞吐量大，处理业务多
缺点：如在更新时发现已经被更新，需要业务重做，而重做依然可能被修改。也就是乐观锁也可能完成一个业务需要N次请求。
特点： 更新带比对条件(版本号,时间戳)[锁交付数据库管理](解决多实例间的并发)


- 悲观所
定义： 很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁

适合：同时刻，高频改写（多写少读）
优点：一次请求完成业务（但在锁的前提下）
缺点：每次请求都存在锁，吞吐量受限（实际并发情况下，并不会每次都冲突，所以部分锁是浪费了）
特点： 全程锁[锁由程序控制]


- 性能优化方向
认领资源（使用乐观锁），多线程，多进程（负载均衡）
 
# 负载均衡场景下，怎么控制多机器多实例间的程序锁
多实例间的`程序锁`只能控制单实例,跨实例就会失去了锁控制. 怎么办?
>可以加入预分配或动态分配或认领制，让多实例同时处理各自的数据(数据被拆分就不再是共享数据了,所以可以并发处理)


---


## 比喻
一个房间(数据库),一扇门A(java服务实例),java悲观锁只能控制当前实例
如果这个房间有另一扇门B( java服务实例 ),A门是不能控制B门的同时有人进入房间的,为了避免公共资源的重复操作,
就可以使用乐观锁,所有人带标记( 版本号,时间戳 ) 工作完成,发现标记已经不存在(被修改)就需要重做(即乐观锁)


乐观锁: 锁在房间的资源
悲观锁: 锁在房间的门


---
# 常见情况
## 1.有高并发，担心出现或已出现共享资源边界超出（超额，成负）
* 建议控制: 使用悲观锁
还有一种场景是数据错乱，原因是没有使用数据库锁。
举例： 库存递减处理
不用使用`update tableName set num = newNum where id = ?` (隐患:并发下会出现重复更新)

应该使用`update tableName set num = num-1 where id = ?`    (目的:数据库管理锁)
 
## 2.悲观锁，把多线程控制成了单线程，吞吐量受阻。
如业务的吞吐性能不达标，需要使用多线程资源定量认领（认领是乐观锁），认领了资源的线程虽依然使用悲观锁，但认领资源的多线程可以同时执行，从而提高了吞吐量

* 建议控制: 多线程进行资源定量认领(低频改写,使用乐观锁),各自认领资源的线程使用悲观锁( 高频改写 )
 
## 3.还不够 =》负载均衡， 多机器 ， 多实例


**参考**
`一分钟教你知道乐观锁和悲观锁的区别 - hongchangfirst - 博客频道 - CSDN.NET`
http://blog.csdn.net/hongchangfirst/article/details/26004335


`mysql乐观锁总结和实践 - 青葱岁月 - ITeye技术网站`

http://chenzhou123520.iteye.com/blog/1863407

<!-- more -->
